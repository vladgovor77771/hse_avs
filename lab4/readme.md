# Содержание

- [Вариант](#вариант)
- [Условия](#условия)
- [Описание программы](#описание-программы)
- [Пример выходного файла](#пример-выходного-файла)
- [Тесты + время выполнения программы](#тесты--время-выполнения-программы)
- [Бенчмарки и генерация случайных данных](#бенчмарки-и-генерация-случайных-данных)
- [Структура данных](#структура-данных)
- [Декомпозиция + размер кода](#декомпозиция--размер-кода)
- [Сборка](#сборка)

# Вариант

Вариант задания 219.

Номер условия задачи: (219 - 1) mod 14 + 1 = 9

Номер дополнительной функции: ((219 - 1) div 14) mod 25 + 1 = 16

# Условия

## Начальные условия задачи

### Обобщенный артефакт, используемый в задании

Тексты, состоящие из цифр и латинских букв, зашифрованные различными способами.

### Базовые альтернативы (уникальные параметры, задающие отличительные признаки альтернатив)

1. Шифрование заменой символов (указатель на массив пар: [текущий символ, замещающий символ]; зашифрованный текст – строка символов)
2. Шифрование циклическим сдвигом кода каждого символа на n (целое число, определяющее сдвиг; зашифрованный текст – строка символов)
3. Шифрование заменой символов на числа (пары: текущий символ, целое число – подстановка при шифровании кода символа в виде короткого целого; зашифрованный текст – целочисленный массив)

### Общие для всех альтернатив переменные

Открытый текст – строка символов.

### Общие для всех альтернатив функции

Частное от деления суммы кодов незашифрованной строки на число символов в этой строке (действительное число)

## Дополнительная функция

Упорядочить элементы контейнера по убыванию используя сортировку методом деления пополам (Binary Insertion). В качестве ключей для сортировки и других действий используются результаты функции, общей для всех альтернатив

# Описание программы

Программа получает на вход количество строк (размер контейнера), затем для каждой строки считывает тип кодировки и настройки кодировки. Затем сортирует контейнер по ключу (дополнительная функция) и выводит в порядке убывания ключа зашифрованные строки. Входные данные считываются из файла. Если программа запускается без аргументов, показываются подсказка для пользователя, как передавать аргументы.

# Пример выходного файла

```
abcd => bcde
mnkj => opml
ouyt => syCx
qxyz => yFGH
```

# Тесты + время выполнения программы

Добавлено в общей сумме 10 тестов, которые покрывают все виды кодировок, а также проверяют правильность сортировки. Тесты лежат в директории `tests`.

- `0_*.in` -- проверка на невалидные данные
- `1_*.in` -- проверка шифрования заменой символов на символы
- `2_*.in` -- проверка шифрования циклическим сдвигом
- `3_*.in` -- проверка шифрования заменой символов на целые числа
- `4_*.in` -- проверка работы сортировки

Все тесты проходятся. Запуск тестирования через `/bin/sh run_tests.sh` (запускает программу, выводит в файл, затем сравнивает реальный вывод с правильным) или же `make test` (запускает `run_tests.sh`).

Вывод `./run_tests.sh`

```
➜  lab5 git:(master) ✗ ./run_tests.sh
Test ./tests/test_1.in succeeded. Time elapsed: 6427816 nanos
Test ./tests/test_2.in succeeded. Time elapsed: 3290295 nanos
Test ./tests/test_3.in succeeded. Time elapsed: 4879863 nanos
Test ./tests/test_4.in succeeded. Time elapsed: 7148635 nanos
```

# Бенчмарки и генерация случайных данных

Скрипт для запуска бенчмарков: `make benchmark && ./bin/app_benchmark.out`.

Ниже представлен один из результатов бенчмарка на `x86_64 Intel Xeon Processor (Icelake) 12 cores 2 GHz`.

```
Sort of 50 strings: 18000.000000 nanoseconds
Sort of 100 strings: 70000.000000 nanoseconds
Sort of 500 strings: 1731000.000000 nanoseconds
Sort of 1000 strings: 5176000.000000 nanoseconds
Sort of 5000 strings: 154786000.000000 nanoseconds
Sort of 10000 strings: 740817000.000000 nanoseconds
Sort of 20000 strings: 4166399000.000000 nanoseconds
Char-char encoding of string with length 50: 3000.000000 nanoseconds
Char-char encoding of string with length 100: 2000.000000 nanoseconds
Char-char encoding of string with length 200: 2000.000000 nanoseconds
Char-char encoding of string with length 300: 5000.000000 nanoseconds
Char-char encoding of string with length 400: 5000.000000 nanoseconds
Char-char encoding of string with length 499: 7000.000000 nanoseconds
Char-int32 encoding of string with length 50: 1000.000000 nanoseconds
Char-int32 encoding of string with length 100: 13000.000000 nanoseconds
Char-int32 encoding of string with length 200: 3000.000000 nanoseconds
Char-int32 encoding of string with length 300: 4000.000000 nanoseconds
Char-int32 encoding of string with length 400: 6000.000000 nanoseconds
Char-int32 encoding of string with length 499: 7000.000000 nanoseconds
Shift encoding of string with length 50: 1000.000000 nanoseconds
Shift encoding of string with length 100: 3000.000000 nanoseconds
Shift encoding of string with length 200: 5000.000000 nanoseconds
Shift encoding of string with length 300: 5000.000000 nanoseconds
Shift encoding of string with length 400: 9000.000000 nanoseconds
Shift encoding of string with length 499: 9000.000000 nanoseconds
```

# Структура данных

```cpp
struct EncodedString {
    char* str;               // Указатель на строку - 8 байт
    enum Encoding encoding;  // Тип шифрования - 4 байта
    union EncodeParams {  // Объединение данных шифрования - 8 байт
        int32_t shift_factor;  // сдвиг
        char* chars;           // либо алфавит замены
        u_int8_t* nums;        // либо числа замены
    } settings;
    union EncodedResult {  // Объединение данных закодированной строки - 8 байт
        char* str;       // либо выходная строка
        u_int8_t* nums;  // либо массив чисел. Использует тип 8 бит для упрощения работы с памятью
    } encoded;
    float key;  // Ключ, сохраненный в памяти
};
```

Отличия от предыдущих лаб: добавлен кеш ключа сортировки (так удобнее делать сортировку на асм).

Структура универсальная для каждой альтернативы, за счет `union` полей. Содержит указатель на исходную строку; `enum` типов кодировок; `union` поле для результата (либо массив `char`, либо массив `int32`); `union` поле с настройками (либо ширина сдвига, либо mapping массив). Размер всей структры 32 байта. При использовании шифрования строки методом циклического сдвига, 4 байта лишние, это единственный минус такого решения. Объявлены 3 функции в `.h` файле, а именно создание структуры `EncodedString* create_es();` с первоначальным выделением памяти (не всей, а только 32 байта + буффер для задания первоначальной строки, так как она есть у всех альтернатив), очищение памяти `void clear_es(EncodedString* es);`, а также функция `void encode(EncodedString* es);`, которая реализует методы зашифровки исходной строки в зависимости от настроек.

# Декомпозиция + размер кода

Исходный код программы находится в директории `src`. Файлы:

- `benchmark.c` (4650 bytes) - точка входа для выполнения бенчмарков
- `main.c` (3474 bytes) - точка входа основной программы
- `encoded_string.h` (1314 bytes) - структура и заголовки функций
- `asmproc.h` (163 bytes) - заголовки функций, реализованных на ассемблере
- `asmproc.asm` (13634 bytes) - функции сортировки и шифрования

Размер файлов брался из вывода `ls -l`. Суммарный размер файлов 23235 байт.

# Сборка

Сборка осуществляется через вызов `make`, который создает необходимые `.o` файлы для последующей линковки, а также сам исполняемый файл `app` в директории `bin`.

Также есть специальные `rules`:

- `make clean` - очистит папку `bin/`
- `make debug` - скомпилирует программу с дополнительными флагами `-fsanitize=address -g`
- `make benchmark` - скомпилирует модуль для проведения бенчмарков `benchmark`
- `make test` - алиас запуска `run_tests.sh`

# Выводы

Разработка на ассемблере это ужасно, оптимизировать код крайне трудно, по сравнению с С. Безусловно, можно сделать так, чтобы программа работала быстрее, чем на С или С++, однако чтобы переплюнуть современные компиляторы, надо как минимум быть на уровне компилятора...

В общем, в моем случае, шифрование действительно работает быстрее реализации на С++. Но сортировка работает медленнее. Почему так? Потому что я не смог реализовать проход одновременно по двум массивам (сортируем массив ключей, массив структур или ссылок на структуры менять зеркально), как в С++. Несмотря на это, я добавил кеш ключа в саму структуру, что позволило избавиться от необзодимости считать его каждый раз в цикле.
